#!/usr/bin/python
#------------------------------------------------------------------------------
'''
Convert SVG Curve Paths to sdfx Bezier Curve Code.
See: https://www.w3.org/TR/SVG/paths.html#PathData
'''
#------------------------------------------------------------------------------

import ply.lex as lex
from ply.lex import TOKEN
import ply.yacc as yacc

#------------------------------------------------------------------------------
# Scanner

digits = r'(\d+)'
sign = r'[+-]'
exponent = r'([eE]' + sign + r'?' + digits + r')'
fractional_constant = r'((' + digits + r'?\.' + digits + r')|(' + digits + r'\.))'
floating_point_constant =  r'((' + fractional_constant + exponent + r'?)|(' + digits + exponent + r'))'
number = r'(' + sign + r'?' + floating_point_constant + r')|(' + sign + r'?' + digits + r')'

tokens = (
  'NUMBER',
  'ELLIPTICAL_ARC',
  'CURVETO',
  'HORIZONTAL_LINETO',
  'LINETO',
  'MOVETO',
  'QUADRATIC_BEZIER_CURVETO',
  'SMOOTH_CURVETO',
  'SMOOTH_QUADRATIC_BEZIER_CURVETO',
  'VERTICAL_LINETO',
  'CLOSEPATH',
)

@TOKEN(number)
def t_NUMBER(t):
    t.value = float(t.value)
    return t

t_ELLIPTICAL_ARC = r'[aA]'
t_CURVETO = r'[cC]'
t_HORIZONTAL_LINETO = r'[hH]'
t_LINETO = r'[lL]'
t_MOVETO = r'[mM]'
t_QUADRATIC_BEZIER_CURVETO = r'[qQ]'
t_SMOOTH_CURVETO = r'[sS]'
t_SMOOTH_QUADRATIC_BEZIER_CURVETO = r'[tT]'
t_VERTICAL_LINETO = r'[vV]'
t_CLOSEPATH = r'[zZ]'

t_ignore = ' ,\t\r\n'

def t_error(t):
    print("illegal character '%s'" % t.value[0])
    t.lexer.skip(1)

lexer = lex.lex()

#------------------------------------------------------------------------------
# Parser

def vertices(cmd, l):
  if len(l) % 2 != 0:
    print('%s needs number pair arguments' % cmd)
    raise SyntaxError
  return [(l[i], l[i+1]) for i in range(0, len(l), 2)]

def relative(x):
  if x.islower():
    if x == 'h':
      return 'rel_x'
    if x == 'v':
      return 'rel_y'
    return 'rel_xy'
  if x == 'H':
    return 'abs_x'
  if x == 'V':
    return 'abs_y'
  return 'abs_xy'

def p_path_command(t):
  '''path_command : moveto
                  | moveto drawto_commands'''
  pass

def p_moveto(t):
  '''moveto : MOVETO number_list'''
  v = vertices('M', t[2])
  global curve
  if len(v) >= 1:
    # the first m/M is always absolute
    x,y = v[0]
    curve.add_endpoint(x,y)
    curve.set_xy(x,y)
  if len(v) >= 2:
    # any remaining vertices are rel/abs lineto commands
    r = relative(t[1])
    for p in v[1:]:
      x,y = p
      curve.add_endpoint(x, y, r)
    # set the absolute position with the last value
    p = v[-1]
    curve.set_xy(p[0],p[1], r)

def p_drawto_commands(t):
  '''drawto_commands : drawto_command
                     | drawto_command drawto_commands'''
  pass

def p_drawto_command(t):
  '''drawto_command : closepath
                    | lineto
                    | horizontal_lineto
                    | vertical_lineto
                    | curveto
                    | smooth_curveto
                    | quadratic_bezier_curveto
                    | smooth_quadratic_bezier_curveto
                    | elliptical_arc'''
  pass

def p_closepath(t):
  'closepath : CLOSEPATH'
  global curve
  curve.closepath()

def p_lineto(t):
  'lineto : LINETO number_list'
  v = vertices('L', t[2])
  global curve
  r = relative(t[1])
  for p in v:
    curve.add_endpoint(p[0], p[1], r)
  # set the absolute position with the last value
  p = v[-1]
  curve.set_xy(p[0], p[1], r)

def p_horizontal_lineto(t):
  'horizontal_lineto : HORIZONTAL_LINETO number_list'
  n = len(t[2])
  if n > 1:
    print('H has multiple numbers')
    raise SyntaxError
  global curve
  r = relative(t[1])
  x = t[2][0]
  curve.add_endpoint(x, 0, r)
  curve.set_xy(x, 0, r)

def p_vertical_lineto(t):
  'vertical_lineto : VERTICAL_LINETO number_list'
  n = len(t[2])
  if n > 1:
    print('V has multiple numbers')
    raise SyntaxError
  global curve
  r = relative(t[1])
  y = t[2][0]
  curve.add_endpoint(0, y, r)
  curve.set_xy(0, y, r)

def p_curveto(t):
  'curveto : CURVETO number_list'
  v = vertices('C', t[2])
  if len(v) % 3 != 0:
    print('C needs splines with 3 vertices each')
    raise SyntaxError
  splines = [(v[i], v[i+1], v[i+2]) for i in range(0, len(v), 3)]
  # emit
  global curve
  r = relative(t[1])
  for s in splines:
    p0,p1,p2 = s
    curve.add_midpoint(p0[0], p0[1], r)
    curve.add_midpoint(p1[0], p1[1], r)
    curve.add_endpoint(p2[0], p2[1], r)
    curve.set_xy(p2[0], p2[1], r)

def p_smooth_curveto(t):
  'smooth_curveto : SMOOTH_CURVETO number_list'
  v = vertices('S', t[2])
  if len(v) % 2 != 0:
    print('S needs splines with 2 vertices each')
    raise SyntaxError
  splines = [(v[i], v[i+1]) for i in range(0, len(v), 2)]
  # emit
  global curve
  r = relative(t[1])
  for s in splines:
    p0,p1 = s
    # the first midpoint is a reflection across the
    # current point of the previous midpoint
    curve.implicit_midpoint()
    curve.add_midpoint(p0[0], p0[1], r)
    curve.add_endpoint(p1[0], p1[1], r)
    curve.set_xy(p1[0], p1[1], r)

def p_quadratic_bezier_curveto(t):
  'quadratic_bezier_curveto : QUADRATIC_BEZIER_CURVETO number_list'
  v = vertices('Q', t[2])
  if len(v) % 2 != 0:
    print('Q needs splines with 2 vertices each')
    raise SyntaxError
  splines = [(v[i], v[i+1]) for i in range(0, len(v), 2)]
  # emit
  global curve
  r = relative(t[1])
  for s in splines:
    p0, p1 = s
    curve.add_midpoint(p0[0], p0[1], r)
    curve.add_endpoint(p1[0], p1[1], r)
    curve.set_xy(p1[0], p1[1], r)

def p_smooth_quadratic_bezier_curveto(t):
  'smooth_quadratic_bezier_curveto : SMOOTH_QUADRATIC_BEZIER_CURVETO number_list'
  v = vertices('T', t[2])
  # emit
  global curve
  r = relative(t[1])
  for p in v:
    # the first midpoint is a reflection across the
    # current point of the previous midpoint
    curve.implicit_midpoint()
    curve.add_endpoint(p[0], p[1], r)
    curve.set_xy(p[0], p[1], r)

def p_elliptical_arc(t):
  'elliptical_arc : ELLIPTICAL_ARC number_list'
  print("A %s" % t[2])

def p_number_list(t):
  '''number_list : NUMBER
                 | NUMBER number_list'''
  n = len(t)
  if n == 2:
    t[0] = [t[1],]
  elif n == 3:
    t[0] = [t[1],] + t[2]
  else:
    assert False

def p_error(t):
  print("syntax error at '%s'" % t.value)

parser = yacc.yacc()

#------------------------------------------------------------------------------

class vertex(object):

  def __init__(self, x, y, t):
    self.x = x
    self.y = y
    self.t = t

  def __str__(self):
    """return a tring for the vertex"""
    s = []
    s.append('b.Add(%f,%f)' % (self.x, self.y))
    if self.t == 'mid':
      s.append('.Mid()')
    return ''.join(s)

class bezier_curve(object):

  def __init__(self):
    self.x, self.y = 0.0, 0.0
    self.vlist = []
    self.closed = False

  def vertex(self, x, y, r):
    """calculate a vertex"""
    if r == 'rel_xy':
      return (self.x + x, self.y + y)
    elif r == 'rel_x':
      return (self.x + x, self.y)
    elif r == 'rel_y':
      return (self.x, self.y + y)
    elif r == 'abs_xy':
      return (x, y)
    elif r == 'abs_x':
      return (x, self.y)
    elif r == 'abs_y':
      return (self.x, y)
    else:
      assert False

  def set_xy(self, x, y, r = 'abs_xy'):
    """set the x/y position"""
    self.x, self.y = self.vertex(x, y, r)

  def add_endpoint(self, x, y, r = 'abs_xy'):
    """add an endpoint vertex"""
    x, y = self.vertex(x, y, r)
    self.vlist.append(vertex(x,y,'end'))

  def add_midpoint(self, x, y, r = 'abs_xy'):
    """add a midpoint vertex"""
    x, y = self.vertex(x, y, r)
    self.vlist.append(vertex(x,y,'mid'))

  def implicit_midpoint(self):
    """add an implicit midpoint"""
    if len(self.vlist) >= 2:
      ep = self.vlist[-1]
      mp = self.vlist[-2]
      assert ep.t == 'end'
      assert mp.t == 'mid'
      x = 2 * ep.x - mp.x
      y = 2 * ep.y - mp.y
      self.vlist.append(vertex(x,y,'mid'))
    else:
      assert False

  def closepath(self):
    """close a bezier curve"""
    self.closed = True

  def flipy(self):
    """flip the y axis"""
    for v in self.vlist:
      # flip the y-axis
      v.y = -v.y

  def offset(self,vmin):
    """offset the curve"""
    for v in self.vlist:
      v.x -= vmin[0]
      v.y -= vmin[1]

  def vmin(self):
    """return the minimum endpoint vertex"""
    x, y = None, None
    for v in self.vlist:
      if v.t == 'end':
        x = (min(x, v.x), v.x)[x is None]
        y = (min(y, v.y), v.y)[y is None]
    return (x, y)

  def vmax(self):
    """return the maximum endpoint vertex"""
    x, y = None, None
    for v in self.vlist:
      if v.t == 'end':
        x = (max(x, v.x), v.x)[x is None]
        y = (max(y, v.y), v.y)[y is None]
    return (x, y)

  def __str__(self):
    s = []
    s.append('b := NewBezier()')
    for v in self.vlist:
      s.append(str(v))
    if self.closed:
      s.append('b.Close()')
    return '\n'.join(s)

#------------------------------------------------------------------------------

curve = bezier_curve()

def main():

  #t="M371 308q-41 0 -72 31.5t-31 71.5q0 69 128 170l239 180q129 111 129 203q0 116 -109 214q-105 95 -223 95q-63 0 -160 -64.5t-120 -64.5q-41 0 -70.5 33t-29.5 74q0 79 153 157q137 70 227 70q201 0 365 -157t164 -357q0 -146 -94 -259q-56 -68 -208 -176 q-153 -111 -213 -180q-35 -41 -75 -41zM316 -72q-44 0 -79.5 29.5t-35.5 71.5q0 62 33 112q37 56 95 56q96 0 96 -118q0 -55 -26 -99q-32 -52 -83 -52z"

  t="M1541 222q0 -48 -16 -160q-16 -101 -107 -101q-55 0 -131 72q-407 385 -934 1111l-5 -227l-3 -228q0 -83 3.5 -249t3.5 -250q0 -269 -104 -269q-55 0 -87 35q-29 31 -29 74q0 42 6.5 127t6.5 127q0 62 4 185.5t4 185.5q0 66 -3 199.5t-3 199.5q0 63 -12 187.5t-12 187.5 q0 46 39.5 84t89.5 38q53 0 131 -116q249 -373 448 -620q237 -293 520 -560q3 43 0 127l-3 126q0 439 -34 699q-4 26 -27 105q-20 68 -20 106q0 116 106 116q174 0 174 -649q0 -111 -3 -331.5t-3 -331.5z"

  global curve
  parser.parse(t)

  #curve.flipy()
  curve.offset(curve.vmin())

  print('%s' % curve)

main()

#------------------------------------------------------------------------------
