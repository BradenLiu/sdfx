#!/usr/bin/python
#------------------------------------------------------------------------------
'''
Convert SVG Curve Paths to sdfx Bezier Curve Code.
See: https://www.w3.org/TR/SVG/paths.html#PathData
'''
#------------------------------------------------------------------------------

import ply.lex as lex
from ply.lex import TOKEN
import ply.yacc as yacc

#------------------------------------------------------------------------------
# Scanner

digits = r'(\d+)'
sign = r'[+-]'
exponent = r'([eE]' + sign + r'?' + digits + r')'
fractional_constant = r'((' + digits + r'?\.' + digits + r')|(' + digits + r'\.))'
floating_point_constant =  r'((' + fractional_constant + exponent + r'?)|(' + digits + exponent + r'))'
number = r'(' + sign + r'?' + floating_point_constant + r')|(' + sign + r'?' + digits + r')'

tokens = (
  'NUMBER',
  'ELLIPTICAL_ARC',
  'CURVETO',
  'HORIZONTAL_LINETO',
  'LINETO',
  'MOVETO',
  'QUADRATIC_BEZIER_CURVETO',
  'SMOOTH_CURVETO',
  'SMOOTH_QUADRATIC_BEZIER_CURVETO',
  'VERTICAL_LINETO',
  'CLOSEPATH',
)

@TOKEN(number)
def t_NUMBER(t):
    t.value = float(t.value)
    return t

t_ELLIPTICAL_ARC = r'[aA]'
t_CURVETO = r'[cC]'
t_HORIZONTAL_LINETO = r'[hH]'
t_LINETO = r'[lL]'
t_MOVETO = r'[mM]'
t_QUADRATIC_BEZIER_CURVETO = r'[qQ]'
t_SMOOTH_CURVETO = r'[sS]'
t_SMOOTH_QUADRATIC_BEZIER_CURVETO = r'[tT]'
t_VERTICAL_LINETO = r'[vV]'
t_CLOSEPATH = r'[zZ]'

t_ignore = ' ,\t\r\n'

def t_error(t):
    print("illegal character '%s'" % t.value[0])
    t.lexer.skip(1)

lexer = lex.lex()

#------------------------------------------------------------------------------
# Parser

def vertices(cmd, l):
  if len(l) % 2 != 0:
    print('%s needs number pair arguments' % cmd)
    raise SyntaxError
  return [(l[i], l[i+1]) for i in range(0, len(l), 2)]

def relative(x):
  if x.islower():
    if x == 'h':
      return 'rel_x'
    if x == 'v':
      return 'rel_y'
    return 'rel_xy'
  if x == 'H':
    return 'abs_x'
  if x == 'V':
    return 'abs_y'
  return 'abs_xy'

def p_path_command(t):
  '''path_command : moveto
                  | moveto drawto_commands'''
  pass

def p_moveto(t):
  '''moveto : MOVETO number_list'''
  v = vertices('M', t[2])
  global curve
  if len(v) >= 1:
    # the first m/M is always absolute
    x,y = v[0]
    curve.add_endpoint(x,y)
    curve.set_xy(x,y)
  if len(v) >= 2:
    # any remaining vertices are rel/abs lineto commands
    r = relative(t[1])
    for p in v[1:]:
      x,y = p
      curve.add_endpoint(x, y, r)
    # set the absolute position with the last value
    p = v[-1]
    curve.set_xy(p[0],p[1], r)

def p_drawto_commands(t):
  '''drawto_commands : drawto_command
                     | drawto_command drawto_commands'''
  pass

def p_drawto_command(t):
  '''drawto_command : closepath
                    | lineto
                    | horizontal_lineto
                    | vertical_lineto
                    | curveto
                    | smooth_curveto
                    | quadratic_bezier_curveto
                    | smooth_quadratic_bezier_curveto
                    | elliptical_arc'''
  pass

def p_closepath(t):
  'closepath : CLOSEPATH'
  global curve
  curve.closepath()

def p_lineto(t):
  'lineto : LINETO number_list'
  v = vertices('L', t[2])
  global curve
  r = relative(t[1])
  for p in v:
    curve.add_endpoint(p[0], p[1], r)
  # set the absolute position with the last value
  p = v[-1]
  curve.set_xy(p[0], p[1], r)

def p_horizontal_lineto(t):
  'horizontal_lineto : HORIZONTAL_LINETO number_list'
  n = len(t[2])
  if n > 1:
    print('H has multiple numbers')
    raise SyntaxError
  global curve
  r = relative(t[1])
  x = t[2][0]
  curve.add_endpoint(x, 0, r)
  curve.set_xy(x, 0, r)

def p_vertical_lineto(t):
  'vertical_lineto : VERTICAL_LINETO number_list'
  n = len(t[2])
  if n > 1:
    print('V has multiple numbers')
    raise SyntaxError
  global curve
  r = relative(t[1])
  y = t[2][0]
  curve.add_endpoint(0, y, r)
  curve.set_xy(0, y, r)

def p_curveto(t):
  'curveto : CURVETO number_list'
  v = vertices('C', t[2])
  if len(v) % 3 != 0:
    print('C needs splines with 3 vertices each')
    raise SyntaxError
  splines = [(v[i], v[i+1], v[i+2]) for i in range(0, len(v), 3)]
  # emit
  global curve
  r = relative(t[1])
  for s in splines:
    p0,p1,p2 = s
    curve.add_midpoint(p0[0], p0[1], r)
    curve.add_midpoint(p1[0], p1[1], r)
    curve.add_endpoint(p2[0], p2[1], r)
  # set the position with the last vertex
  if len(splines) >= 1:
    s = splines[-1]
    p = s[-1]
    curve.set_xy(p[0], p[1], r)

def p_smooth_curveto(t):
  'smooth_curveto : SMOOTH_CURVETO number_list'
  v = vertices('S', t[2])
  if len(v) % 2 != 0:
    print('S needs splines with 2 vertices each')
    raise SyntaxError
  s = [(v[i], v[i+1]) for i in range(0, len(v), 2)]
  print("S %s" % s)

def p_quadratic_bezier_curveto(t):
  'quadratic_bezier_curveto : QUADRATIC_BEZIER_CURVETO number_list'
  v = vertices('Q', t[2])
  if len(v) % 2 != 0:
    print('Q needs splines with 2 vertices each')
    raise SyntaxError
  splines = [(v[i], v[i+1]) for i in range(0, len(v), 2)]
  # emit
  global curve
  r = relative(t[1])
  for s in splines:
    p0, p1 = s
    curve.add_midpoint(p0[0], p0[1], r)
    curve.add_endpoint(p1[0], p1[1], r)
  # set the position with the last vertex
  if len(splines) >= 1:
    s = splines[-1]
    p = s[-1]
    curve.set_xy(p[0], p[1], r)

def p_smooth_quadratic_bezier_curveto(t):
  'smooth_quadratic_bezier_curveto : SMOOTH_QUADRATIC_BEZIER_CURVETO number_list'
  v = vertices('T', t[2])
  print("T %s" % v)

def p_elliptical_arc(t):
  'elliptical_arc : ELLIPTICAL_ARC number_list'
  print("A %s" % t[2])

def p_number_list(t):
  '''number_list : NUMBER
                 | NUMBER number_list'''
  n = len(t)
  if n == 2:
    t[0] = [t[1],]
  elif n == 3:
    t[0] = [t[1],] + t[2]
  else:
    assert False

def p_error(t):
  print("syntax error at '%s'" % t.value)

parser = yacc.yacc()

#------------------------------------------------------------------------------

class bezier_curve(object):

  def __init__(self, name):
    self.x = 0.0
    self.y = 0.0
    self.name = name
    self.s = []
    self.start_curve()

  def vertex(self, x, y, r):
    """calculate a vertex"""
    if r == 'rel_xy':
      return (self.x + x, self.y + y)
    elif r == 'rel_x':
      return (self.x + x, self.y)
    elif r == 'rel_y':
      return (self.x, self.y + y)
    elif r == 'abs_xy':
      return (x, y)
    elif r == 'abs_x':
      return (x, self.y)
    elif r == 'abs_y':
      return (self.x, y)
    else:
      assert False

  def set_xy(self, x, y, r = 'abs_xy'):
    """set the x/y position"""
    self.x, self.y = self.vertex(x, y, r)

  def start_curve(self):
    """start a bezier curve"""
    self.s.append('%s := NewBezier()' % self.name)

  def endpoint_str(self, x, y, r):
    x, y = self.vertex(x, y, r)
    return '%s.Add(%f,%f)' % (self.name, x, y)

  def add_endpoint(self, x, y, r = 'abs_xy'):
    """add an endpoint vertex"""
    self.s.append(self.endpoint_str(x, y, r))

  def add_midpoint(self, x, y, r = 'abs_xy'):
    """add a midpoint vertex"""
    self.s.append('%s.Mid()' % self.endpoint_str(x, y, r))

  def closepath(self):
    """close a bezier curve"""
    self.s.append('%s.Close()' % self.name)

  def __str__(self):
    return '\n'.join(self.s)

curve = bezier_curve('b')

#------------------------------------------------------------------------------

test_path = [
  "M10 10 H 90 V 90 H 10 L 10 10",
  "M1 2 C 1 2 3 4 5 6",
  "M139,356 C100,100 372,91 398,414 Z",
  "M10 10 C 20 20, 40 20, 50 10",
  "M70 10 C 70 20, 120 20, 120 10",
  "M130 10 C 120 20, 180 20, 170 10",
  "M10 60 C 20 80, 40 80, 50 60",
  "M70 60 C 70 80, 110 80, 110 60",
  "M130 60 C 120 80, 180 80, 170 60",
  "M10 110 C 20 140, 40 140, 50 110",
  "M70 110 C 70 140, 110 140, 110 110",
  "M130 110 C 120 140, 180 140, 170 110",
  "m -572.85714,869.50506 c 192.88322,-1.616 423.19532,2.38809 582.8571395,-98.57143 C 156.42598,678.34359 271.53116,497.47081 276.29115,324.16718 281.50356,134.39204 105.19248,-7.6659933 11.984471,-180.33054 c -24.093373,-44.63212 -34.60762,-119.917 -55.714286,-141.59297 -23.725303,-24.36524 -69.204155,-10.6815 -86.270185,12.85714 -30.05262,41.45064 8.50277,103.2095 25.71429,151.42858 61.988775,173.665188 273.35357,302.77743 273.66295,480.7582 C 169.6136,459.09331 74.436588,597.39293 -37.381851,674.7578 -186.7423,778.09721 -574.28571,767.61494 -574.28571,767.61494 Z"
]

def main():
# t="M 100 350 q 150 -300 300 0"
#  t="M150 0 L75 200 L225 200 Z"
#  t = "M10 10 H 90 V 90 H 10 L 10 10"
  t = "m -572.85714,869.50506 c 192.88322,-1.616 423.19532,2.38809 582.8571395,-98.57143 C 156.42598,678.34359 271.53116,497.47081 276.29115,324.16718 281.50356,134.39204 105.19248,-7.6659933 11.984471,-180.33054 c -24.093373,-44.63212 -34.60762,-119.917 -55.714286,-141.59297 -23.725303,-24.36524 -69.204155,-10.6815 -86.270185,12.85714 -30.05262,41.45064 8.50277,103.2095 25.71429,151.42858 61.988775,173.665188 273.35357,302.77743 273.66295,480.7582 C 169.6136,459.09331 74.436588,597.39293 -37.381851,674.7578 -186.7423,778.09721 -574.28571,767.61494 -574.28571,767.61494 Z"
  global curve
  parser.parse(t)
  print('%s' % curve)

main()

#------------------------------------------------------------------------------
